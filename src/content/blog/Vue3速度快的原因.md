---
title: "Vue3速度快的原因"
tag: "性能优化"
classify: "md"
description: "性能提升"
pubDate: "2023/2/16 16:22:29"
heroImage: ""
---

# Vue3速度快的原因

## Vue3.0 性能提升体现在哪些方面

- 代码层面性能优化主要体现在全新响应式API，基于Proxy实现，初始化时间和内存占用均大幅改进；
- 编译层面做了更多编译优化处理，比如静态标记pachFlag（diff算法增加了一个静态标记，只对比有标记的dom元素）、事件增加缓存、静态提升（对不参与更新的元素，会做静态提- 升，只会被创建一次，之后会在每次渲染时候被不停的复用）等，可以有效跳过大量diff过程；
- 打包时更好的支持tree-shaking，因此整体体积更小，加载更快
- ssr渲染以字符串方式渲染

## 编译阶段

- diff算法优化
- 静态提升
- 事件监听缓存
- SSR优化

### diff 算法优化


- Vue 2x 中的虚拟 dom 是进行全量的对比
- Vue 3x 中新增了静态标记(PatchFlag)，在与上次虚拟结点进行对比的时候，值对比 带有 patch flag 的节点，并且可以通过 flag 的信息得知当前节点要对比的具体内容

### hoistStatic 静态提升

- Vue 2x : 无论元素是否参与更新，每次都会重新创建。
- Vue 3x : 对不参与更新的元素，会做静态提升，只会被创建一次，之后会在每次渲染时候被不停的复用。这样就免去了重复的创建节点，优化了运行时候的内存占用

### 事件监听缓存
- 默认情况下 绑定事件会被视为动态绑定 ，所以每次都会去追踪它的变化
- 但是因为是同一个函数，所以没有追踪变化，直接缓存起来复用即可

### SSR优化

当静态内容大到一定量级时候，会用createStaticVNode方法在客户端去生成一个static node，这些静态node，会被直接innerHtml，就不需要创建对象，然后根据对象渲染


## 源码体积

相比Vue2，Vue3整体体积变小了，除了移出一些不常用的API，再重要的是Tree shanking
任何一个函数，如ref、reactive、computed等，仅仅在用到的时候才打包，没用到的模块都被Tree shanking掉，打包的整体体积变小

## 响应式系统

>vue2中采用 defineProperty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式，vue3采用proxy重写了响应式系统，因为proxy可以对整个对象进行监听，所以不需要深度遍历

- 可以监听动态属性的添加
- 可以监听到数组的索引和数组length属性
- 可以监听删除属性





